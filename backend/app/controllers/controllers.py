from flask import Blueprint,request,Response,jsonify
from ..helpers.dbConfig import databaseSetup
from ..helpers.tokenizor import compute_similarity
import json
from  werkzeug.security import generate_password_hash, check_password_hash 
import jwt 
from datetime import datetime, timedelta 
from functools import wraps 
import uuid
from flask_cors import CORS, cross_origin

dbObj = databaseSetup()
main = Blueprint('main', __name__)
cors = CORS(main)
# main.config['CORS_HEADERS'] = 'Content-Type'


Users_collections=dbObj["users"]
Recommendations_collections=dbObj["recommendations"]
Connected_users_collections=dbObj["connected_users"]
User_requests_collections=dbObj["user_requests"]
User_messages_collections=dbObj["user_message_pair"]
User_messages_rooms_collections=dbObj["user_message_room"]
ScholarList_collections=dbObj["ScholarList"]

SECRET_KEY="Authentication Secret Goes Here"

# Register - Post
# Login - Post
# Home - GET
# Upload - POST
# USER Profile - GET, Researcher profile-GET
# Profile - PUT
# Logout - GET
# ChatList - GET
# Chat -server
# Connection request and accept request

# Collections:-

# users->{
        # id:
#     full_name: string
#     email: string
#     password: string
#     scholars_link: url if any(verify before saving)
#     interests:[]
# }

# recommendations->{
#     user_id: id
#     keywords (based on interests or uploaded papers if any): []
#     interests: []
#     researchers:[] => Professor names list.
#     papers:[]?????? Names of recommended papers => {Professor name, [title]}
# }

# scholars->{
#     (Professor name):{title:[(Keywords)], interests:[], scholars_link:link }, id: uuid,...
# }

# TODO: add email or id to the scholar list.

# connected_users->{
#     user_id:id
#     connected_to:[]
# }

# user_requests:{
# user_id: id
# requests:[{user_id:, user_name:},...]
# }

# message_pairs->{
#     user_1:
#     user_2:
#     id:
# }
# message_room->{
#     id:
#     sender: id
#     receiver: id
#     timestamp:
#     mesasge: string
# }

"""
scholar List design:
{
    researcher: <name>,
    scholars_link: <link>,
    papers: [
        title: <title>,
        keywords: []
    ]
}
"""


@main.route('/', methods = ['GET'])
@cross_origin()
def index():
    resp = Response("Ok", status=200, mimetype='application/json')
    return resp


@main.route('/test', methods = ['GET'])
@cross_origin()
def test_connection():
    resp = Response("EasyConnect server is up and working!", status=200, mimetype='application/json')
    return resp


@main.route('/register', methods = ['POST'])
@cross_origin()
def register_user():
    data=request.get_json()
    email=data['email']
    password=data['password']
    full_name=data['full_name']
    scholars_link=data['scholars_link']
    interests=data['interests']
    id = str(uuid.uuid4())

    # TODO: verify scholar link.

    user_exists=Users_collections.find_one({"email": email})

    if not user_exists:  
        user_data={"id":id,"email":email,"password":generate_password_hash(password) ,"full_name":full_name,"scholars_link":scholars_link,"interests":interests}
        print(user_data)
        update_recomendations(user_data, interests)
        user_id=Users_collections.insert_one(user_data)

        resp = Response('User Registered Successfully', status=201, mimetype='application/json')
    else: 
        resp = Response('User already exists. Please Log in.', status=202, mimetype='application/json')
    return resp

@main.route('/login', methods = ['GET','POST'])
@cross_origin()
def login_user():
    data=request.get_json()
    email=data['email']
    password=data['password']
    user=Users_collections.find_one({"email": email},{'_id': False})
    if not user: 
        resp = Response('User does not exist', 401, {'WWW-Authenticate' : 'Basic realm ="User does not exist"'})
        return resp

    if check_password_hash(user['password'], password): 
        token = jwt.encode({ 
            'user':user
        }, SECRET_KEY) 
   
        resp =Response(json.dumps({'token' : token.decode('UTF-8')}), 200) 
        return resp

    resp=('Wrong Password', 403, {'WWW-Authenticate' : 'Basic realm ="Wrong Password !!"'}) 
    return resp

@main.route('/recommendations', methods = ['GET'])
@cross_origin()
def get_recommendations():
    auth_header = request.headers.get('Authorization')

    if auth_header:
        auth_token = auth_header.split(" ")[1]
    else:
        auth_token = ''

    if auth_token != '':

        user = jwt.decode(auth_token, SECRET_KEY)["user"]
        recommendations = Recommendations_collections.find_one({"user_id": user["id"]}, {"_id": 0})
        print(recommendations)

        if recommendations:
            resp = Response(json.dumps(recommendations), status=200, mimetype='application/json')
        else:
            resp = Response("No data found", status=404, mimetype='application/json')
    
        return resp

# Header format:
# Authorization: Bearer <jwt_token>
# @main.route('/update_interests', methods = ['POST'])
"""
Method to update the recommendations based on user interests.
"""
def update_recomendations(user, interests):

    recommendation_col = Recommendations_collections.find_one({"user_id": user["id"]})

    # Get the scholars list.
    scholar_list = ScholarList_collections.find()

    scholar_cosine_rel = []
    for scholar in scholar_list:
        cosine_sum = 0
            
        for paper in scholar["papers"]:
            cosine_sum += compute_similarity(interests, paper["keywords"])
        
        scholar_cosine_rel.append((scholar, cosine_sum))

    # Find the top 10 scholars with cosine sum and update the recommendation.
    new_scholar = sorted(scholar_cosine_rel, key=lambda item: item[1])

    # print(new_scholar[:10])
    resp = [item[0] for item in new_scholar[:10]]
    # print(res)
    # update Recommendations_collections
    if recommendation_col:
        new_recommendation = recommendation_col.copy()
        new_recommendation["interests"] = interests
        new_recommendation["researchers"] = resp
        payload = {"$set": new_recommendation}
        Recommendations_collections.update_one(recommendation_col, payload)

    # Otherwise create new recommendation.
    else:
        new_recommendation = {}
        new_recommendation["user_id"] = user["id"]
        new_recommendation["keywords"] = []
        new_recommendation["interests"] = interests
        new_recommendation["researchers"] = resp
        Recommendations_collections.insert_one(new_recommendation)

@main.route('/profile', methods = ['GET', 'PUT'])
@cross_origin()
def get_user_profile():

    if request.method == 'GET':
        args=request.args
        resp = Response("profile endpoint", status=200, mimetype='application/json')
        return resp

    # Update user profile
    if request.method == 'PUT':
        data = request.get_json()
        email = data['email']
        password = data['password'] 
        full_name = data['full_name']
        scholars_link = data['scholars_link']
        interests = data['interests']

        auth_header = request.headers.get('Authorization')

        if auth_header:
            auth_token = auth_header.split(" ")[1]
        else:
            auth_token = ''

        if auth_token != '':

            user = jwt.decode(auth_token, SECRET_KEY)["user"]

            #Update user collection
            user_update = user.copy()
            if len(interests) > 0: user_update["interests"] = interests
            if email: user_update["email"] = email
            if password: user_update["password"] = generate_password_hash(password)
            if full_name: user_update["full_name"] = full_name
            if scholars_link: user_update["scholars_link"] = scholars_link

            req = {"$set": user_update}
            Users_collections.update(user, req)

            update_recomendations(user, interests)

        return Response("Update interests", status=200, mimetype='application/json')


# @main.route('/isconnected', methods = ['GET'])
# def get_connected_status():
#     args=request.args
#     resp = Response("isconnected endpoint", status=200, mimetype='application/json')
#     return resp
    
@main.route('/message', methods = ['POST', 'GET'])
@cross_origin()
def message():

    ## send message
    if request.method == 'POST':
        args=request.args
        user_id=args['user_id']
        data=request.get_json()
        message_room_id=data["message_room_id"]
        message=data["message"]
        message_pair=User_messages_rooms_collections.find_one({"message_room_id":message_room_id},{"_id":False})
        message_pair["messages"].append({"sender_id":user_id,"message":message, "timestamp":datetime.now()})
        User_messages_rooms_collections.update_one({"message_room_id":message_room_id},{"$set":{"messages":message_pair["messages"]}})
        resp = Response("message endpoint", status=200, mimetype='application/json')
        return resp

    ## get message room id
    if request.method == "GET":
        args=request.args
        user_id=args['user_id']
        connection_id=args['connection_id']
        message_pair=User_messages_collections.find_one({"user_1": user_id,"user_2":connection_id })
        if not message_pair:
            message_pair=User_messages_collections.find_one({"user_2": user_id,"user_1":connection_id })
        if not message_pair:
            message_room_id=str(uuid.uuid4())
            User_messages_collections.insert_one({"user_2": user_id,"user_1":connection_id, "message_room_id":message_room_id})
            User_messages_rooms_collections.insert_one({"message_room_id":message_room_id,"messages":[]})
            resp = Response(json.dumps({"message_room_id":message_room_id,"messages":[]}), status=200, mimetype='application/json')

        else:
            message_room_id=message_pair['message_room_id']
            message_pair=User_messages_rooms_collections.find_one({"message_room_id":message_room_id},{"_id":False})
            print(message_pair)
            resp=Response(json.dumps(message_pair), status=200, mimetype='application/json')

        return resp
        
@main.route('/connect', methods = ['POST', 'GET'])
@cross_origin()
def connect_user():
    ##accept connection request
    if request.method == 'POST':
        data = request.get_json()
        user_1_data = data['accpeted_user']
        user_2_data=jwt.decode(data['jwt_token'], SECRET_KEY)["user"]

        user_1_id=user_1_data["id"]
        user_2_id=user_2_data["id"]
        
        # Connected_users_collections
        user_1=Connected_users_collections.find_one({"id": user_1_id})
        user_2=Connected_users_collections.find_one({"id": user_2_id})

        if not user_1:
            Connected_users_collections.insert_one({"id":user_1_id,"connected_to":[{"id":user_2_id,"full_name":user_2_data["full_name"],"email":user_2_data["email"]}]})
        else:
            user_1["connected_to"].append({"id":user_2_id,"full_name":user_2_data["full_name"],"email":user_2_data["email"]})
            Connected_users_collections.update_one({"id":user_1_id},{"$set":{"connected_to":user_1["connected_to"]}})

        if not user_2:
            Connected_users_collections.insert_one({"id":user_2_id,"connected_to":[user_1_data]})
        else:
            user_2["connected_to"].append(user_1_data)
            Connected_users_collections.update_one({"id":user_2_id},{"$set":{"connected_to":user_2["connected_to"]}})
        user_2_requests=User_requests_collections.find_one({"user_id":user_2_id})


        for i in range(len(user_2_requests['requests'])):
            if user_2_requests['requests'][i]['id']==user_1_id:
                break
        del user_2_requests['requests'][i]
        User_requests_collections.update_one({"user_id": user_2_id}, {"$set":{"requests":user_2_requests['requests']}})

        resp = Response("Connection Accepted Successfully", status=200, mimetype='application/json')
        return resp
    
    ## get list of conencted users
    if request.method == 'GET':
        auth_header = request.headers.get('Authorization')
        if auth_header:
            jwt_token = auth_header.split(" ")[1]                
            user_data=jwt.decode(jwt_token, SECRET_KEY)
        user=None
        if user_data!=None:
            user_data=user_data["user"]
            user=Connected_users_collections.find_one({"id": user_data['id']})
        if user!=None:
            resp=Response(json.dumps(user['connected_to']), status=200, mimetype='application/json')
        else:
            resp = Response(json.dumps([]), status=200, mimetype='application/json')
        return resp

@main.route('/requests', methods = ['GET', 'POST'])
@cross_origin()
def connection_requests():
    ## send request to connect to a user
    if request.method == 'POST':
        data = request.get_json()
        requesting_user=jwt.decode(data['requesting_user_jwt'], SECRET_KEY)["user"]
        requesting_user_data={"id":requesting_user['id'], "email":requesting_user['email'],"full_name":requesting_user['full_name']}
        requested_to=data['id']
        user=User_requests_collections.find_one({"user_id": requested_to})

        if not user:
            user={}
            user['user_id']=requested_to
            user['requests']=[requesting_user_data]
            User_requests_collections.insert_one(user)
            resp = Response("Request Sent Successfully", status=200, mimetype='application/json')
            return resp
        user['requests'].append(requesting_user_data)
        User_requests_collections.update_one({"user_id": requested_to}, {"$set":{"requests":user['connected_to']}})
        resp = Response("Request Sent Successfully", status=200, mimetype='application/json')
        return resp

    ## get list of connection requests
    if request.method == 'GET':
        auth_header = request.headers.get('Authorization')
        if auth_header:
            jwt_token = auth_header.split(" ")[1]                
            user_data=jwt.decode(jwt_token, SECRET_KEY)
        user=None
        if user_data!=None:
            user_data=user_data["user"]
            user=User_requests_collections.find_one({"user_id": user_data['id']})

        if user!=None:
            resp=Response(json.dumps(user['requests']), status=200, mimetype='application/json')
        else:
            resp = Response(json.dumps([]), status=200, mimetype='application/json')
    return resp

@main.route('/upload', methods = ['POST'])
@cross_origin()
def upload_paper():
    if request.method == 'POST':
        f = request.files['the_file']
        data = request.get_json()


